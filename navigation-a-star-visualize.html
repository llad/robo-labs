<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>A* Step Visualizer</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0f0f12; color:#ddd; font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { display:flex; gap:12px; padding:12px; align-items:flex-start; }
    canvas { background:#121218; border:1px solid #2a2a33; border-radius:10px; }
    .panel { width: 520px; display:flex; flex-direction:column; gap:10px; }
    .card { border:1px solid #2a2a33; background:#121218; padding:10px; border-radius:10px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button, select, input[type="range"] {
      background:#1a1a22; color:#ddd; border:1px solid #2a2a33; border-radius:10px; padding:8px 10px;
    }
    button { cursor:pointer; }
    button:active { transform: translateY(1px); }
    .k { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted { color:#a9a9b4; }
    .small { font-size: 12px; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #2a2a33; padding:6px 6px; text-align:left; }
    th { color:#bdbdd0; font-weight:600; }
    textarea { width:100%; min-height:120px; resize:vertical; background:#0f0f12; color:#ddd; border:1px solid #2a2a33; border-radius:10px; padding:8px; }
    .pill { display:inline-block; padding:2px 7px; border:1px solid #2a2a33; border-radius:999px; background:#1a1a22; }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c"></canvas>

  <div class="panel">
    <div class="card">
      <div class="row">
        <button id="btnStep">Step</button>
        <button id="btnRun">Run</button>
        <button id="btnReset">Reset Search</button>
        <button id="btnClear">Clear Walls</button>
        <span id="status" class="pill k small">RUNNING</span>
      </div>

      <div class="row" style="margin-top:8px">
        <label class="small">Click:
          <select id="clickMode">
            <option value="wall">Toggle wall</option>
            <option value="start">Set start</option>
            <option value="goal">Set goal</option>
          </select>
        </label>

        <label class="small">Heuristic:
          <select id="heuristicSel">
            <option value="manhattan">Manhattan</option>
            <option value="euclidean">Euclidean</option>
            <option value="chebyshev">Chebyshev</option>
            <option value="zero">Zero (Dijkstra)</option>
          </select>
        </label>

        <label class="small">Speed:
          <input id="speed" type="range" min="1" max="20" step="1" value="6" />
          <span id="speedVal" class="k small">6 steps/s</span>
        </label>
      </div>

      <div class="muted small" style="margin-top:8px">
        Colors: <span class="pill k">current</span> magenta, <span class="pill k">open</span> amber, <span class="pill k">closed</span> blue.
        When finished, the <span class="pill k">optimal path</span> is drawn in bright green.
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between">
        <div class="k">Core variables</div>
        <div id="coreLine" class="k small muted"></div>
      </div>
      <table class="k small" id="varsTable"><tbody></tbody></table>
    </div>

    <div class="card">
      <div class="k">Open set (sorted view)</div>
      <table class="k small" id="openTable">
        <thead><tr><th>node</th><th>g</th><th>h</th><th>f</th><th>parent</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="card">
      <div class="k">Neighbor checks (this step)</div>
      <table class="k small" id="nbrTable">
        <thead><tr><th>nbr</th><th>pass?</th><th>tent_g</th><th>old_g</th><th>action</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="card">
      <div class="k">Optimal route (when complete)</div>
      <div id="pathBox" class="k small" style="margin-top:8px; white-space:pre-wrap;"></div>
    </div>

    <div class="card">
      <div class="k">Step log</div>
      <textarea id="log" class="k small" readonly></textarea>
    </div>
  </div>
</div>

<script>
(() => {
  // ---------- Small grid ----------
  const CELL = 36, GRID_W = 10, GRID_H = 7;
  const W = GRID_W * CELL, H = GRID_H * CELL;

  const canvas = document.getElementById('c');
  canvas.width = W; canvas.height = H;
  const ctx = canvas.getContext('2d');

  // UI
  const btnStep = document.getElementById('btnStep');
  const btnRun  = document.getElementById('btnRun');
  const btnReset= document.getElementById('btnReset');
  const btnClear= document.getElementById('btnClear');
  const clickMode = document.getElementById('clickMode');
  const heuristicSel = document.getElementById('heuristicSel');
  const speed = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const status = document.getElementById('status');
  const coreLine = document.getElementById('coreLine');

  const varsTbody = document.querySelector('#varsTable tbody');
  const openTbody = document.querySelector('#openTable tbody');
  const nbrTbody  = document.querySelector('#nbrTable tbody');
  const logEl = document.getElementById('log');
  const pathBox = document.getElementById('pathBox');

  speed.addEventListener('input', () => speedVal.textContent = `${speed.value} steps/s`);

  // ---------- Grid + endpoints ----------
  let grid = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0));
  let start = [1, 3];
  let goal  = [8, 3];

  // default obstacle column
  for (const [x,y] of [[4,1],[4,2],[4,3],[4,4],[4,5]]) grid[y][x] = 1;

  // ---------- Helpers ----------
  const key = (x,y) => `${x},${y}`;
  const parseKey = (k) => k.split(',').map(Number);
  const inBounds = (x,y) => x>=0 && x<GRID_W && y>=0 && y<GRID_H;
  const passable = (x,y) => grid[y][x] === 0;
  const neighbors4 = ([x,y]) => [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
  const cellCenter = ([cx,cy]) => [(cx+0.5)*CELL, (cy+0.5)*CELL];

  function hManhattan(a,b){ return Math.abs(a[0]-b[0]) + Math.abs(a[1]-b[1]); }
  function hEuclid(a,b){ return Math.hypot(a[0]-b[0], a[1]-b[1]); }            // admissible, less tight on 4-neighbor
  function hChebyshev(a,b){ return Math.max(Math.abs(a[0]-b[0]), Math.abs(a[1]-b[1])); } // admissible but looser here
  function hZero(){ return 0; }                                                // Dijkstra

  function heuristic(a,b){
    switch (heuristicSel.value) {
      case "euclidean": return hEuclid(a,b);
      case "chebyshev": return hChebyshev(a,b);
      case "zero": return 0;
      case "manhattan":
      default: return hManhattan(a,b);
    }
  }

  function log(line){
    logEl.value += line + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ---------- Min-heap ----------
  function heapLess(a,b){
    if (a.f !== b.f) return a.f < b.f;
    return a.tie < b.tie; // tie-break = insertion order proxy
  }
  function siftUp(h,i){ while(i>0){ const p=(i-1)>>1; if(heapLess(h[p],h[i])) break; [h[p],h[i]]=[h[i],h[p]]; i=p; } }
  function siftDown(h,i){
    while(true){
      const l=i*2+1,r=l+1; let m=i;
      if(l<h.length && heapLess(h[l],h[m])) m=l;
      if(r<h.length && heapLess(h[r],h[m])) m=r;
      if(m===i) break;
      [h[m],h[i]]=[h[i],h[m]]; i=m;
    }
  }
  function heapPush(h,it){ h.push(it); siftUp(h,h.length-1); }
  function heapPop(h){
    if(!h.length) return null;
    const top=h[0], last=h.pop();
    if(h.length){ h[0]=last; siftDown(h,0); }
    return top;
  }

  // ---------- A* state ----------
  const AStarState = () => ({
    stepCount: 0,
    openHeap: [],
    openSet: new Set(),
    closed: new Set(),
    cameFrom: new Map(),  // child -> parent
    gScore: new Map(),
    fScore: new Map(),
    current: null,
    lastNeighborReport: [],
    finished: false,
    outcome: "running", // running | no_path | reached_goal
    insertionCounter: 0,
  });

  let ast = AStarState();

  function reconstructPathStartToGoal(){
    const sK = key(start[0],start[1]);
    const gK = key(goal[0],goal[1]);
    if (!ast.gScore.has(gK)) return [];
    const path = [];
    let cur = gK;
    path.push(cur);
    while (cur !== sK) {
      cur = ast.cameFrom.get(cur);
      if (!cur) return []; // shouldn't happen if reachable
      path.push(cur);
    }
    path.reverse(); // start -> goal
    return path;
  }

  function resetSearch(){
    ast = AStarState();
    logEl.value = "";
    pathBox.textContent = "(not reached yet)";
    status.textContent = "RUNNING";

    const sK = key(start[0],start[1]);
    const h0 = heuristic(start, goal);
    const f0 = 0 + h0;

    ast.gScore.set(sK, 0);
    ast.fScore.set(sK, f0);
    heapPush(ast.openHeap, { k: sK, f: f0, tie: ast.insertionCounter++, g: 0, h: h0 });
    ast.openSet.add(sK);

    log(`Init: start=${sK} goal=${key(goal[0],goal[1])} heuristic=${heuristicSel.value}`);
    log(`g(start)=0, h(start)=${fmt(h0)}, f(start)=${fmt(f0)}`);
    renderAll();
  }

  function fmt(x){ return Number.isInteger(x) ? String(x) : x.toFixed(2); }

  function stepAStar(){
    if (ast.finished) return;

    ast.lastNeighborReport = [];
    ast.stepCount += 1;

    // Pop next valid from heap (skip stale by membership)
    let popped = null;
    while (ast.openHeap.length) {
      const cand = heapPop(ast.openHeap);
      if (ast.openSet.has(cand.k)) { popped = cand; break; }
    }

    if (!popped) {
      ast.finished = true;
      ast.outcome = "no_path";
      status.textContent = "NO PATH";
      log(`Step ${ast.stepCount}: open set empty -> NO PATH`);
      renderAll();
      return;
    }

    const curK = popped.k;
    ast.current = curK;
    ast.openSet.delete(curK);
    ast.closed.add(curK);

    log(`\nStep ${ast.stepCount}: pop current=${curK} f=${fmt(popped.f)} (g=${fmt(popped.g)}, h=${fmt(popped.h)})`);

    const goalK = key(goal[0],goal[1]);
    if (curK === goalK) {
      ast.finished = true;
      ast.outcome = "reached_goal";
      status.textContent = "REACHED GOAL";

      const path = reconstructPathStartToGoal();
      pathBox.textContent = path.length ? path.join("  ->  ") : "(path missing)";
      log(`Current is goal. DONE. Path length=${path.length ? path.length-1 : "?"} moves.`);
      renderAll();
      return;
    }

    const [cx,cy] = parseKey(curK);
    const curG = ast.gScore.get(curK);

    for (const [nx,ny] of neighbors4([cx,cy])) {
      const nbrK = key(nx,ny);
      const inB = inBounds(nx,ny);
      const can = inB && passable(nx,ny);
      const isClosed = ast.closed.has(nbrK);

      let action = "";
      let oldG = ast.gScore.has(nbrK) ? ast.gScore.get(nbrK) : null;
      let tentG = null;

      if (!inB) action = "skip (OOB)";
      else if (!can) action = "skip (wall)";
      else if (isClosed) action = "skip (closed)";
      else {
        tentG = curG + 1;
        if (oldG === null || tentG < oldG) {
          ast.cameFrom.set(nbrK, curK);
          ast.gScore.set(nbrK, tentG);

          const h = heuristic([nx,ny], goal);
          const f = tentG + h;
          ast.fScore.set(nbrK, f);

          heapPush(ast.openHeap, { k: nbrK, f, tie: ast.insertionCounter++, g: tentG, h });
          ast.openSet.add(nbrK);

          action = (oldG === null) ? "discover (add/open)" : "improve g (update)";
          log(`  Neighbor ${nbrK}: tent_g=${fmt(tentG)} old_g=${oldG===null?"-":fmt(oldG)} h=${fmt(h)} f=${fmt(f)} -> ${action}`);
        } else {
          action = "no change (worse g)";
          log(`  Neighbor ${nbrK}: tent_g=${fmt(tentG)} >= old_g=${fmt(oldG)} -> ${action}`);
        }
      }

      ast.lastNeighborReport.push({
        nbr: nbrK,
        pass: can ? "yes" : (inB ? "no" : "OOB"),
        tentG: tentG === null ? "-" : fmt(tentG),
        oldG: oldG === null ? "-" : fmt(oldG),
        action
      });
    }

    renderAll();
  }

  // ---------- Render ----------
  function drawCell([x,y], fill){
    ctx.fillStyle = fill;
    ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
  }
  function drawGridLines(){
    ctx.strokeStyle = "#2a2a33";
    ctx.lineWidth = 1;
    for (let x=0; x<=W; x+=CELL){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for (let y=0; y<=H; y+=CELL){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  }
  function renderCanvas(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#0f0f12";
    ctx.fillRect(0,0,W,H);

    // walls
    for (let y=0;y<GRID_H;y++) for (let x=0;x<GRID_W;x++) if (grid[y][x]===1) drawCell([x,y], "#4a4a4a");

    // closed
    ctx.globalAlpha = 0.88;
    for (const ck of ast.closed){
      const [x,y] = parseKey(ck);
      if (grid[y][x]===1) continue;
      if ((x===start[0]&&y===start[1]) || (x===goal[0]&&y===goal[1])) continue;
      drawCell([x,y], "#1b2a40");
    }

    // open
    for (const ok of ast.openSet){
      const [x,y] = parseKey(ok);
      if (grid[y][x]===1) continue;
      if ((x===start[0]&&y===start[1]) || (x===goal[0]&&y===goal[1])) continue;
      drawCell([x,y], "#3a2f18");
    }

    // current
    if (ast.current){
      const [x,y] = parseKey(ast.current);
      drawCell([x,y], "#7a1f3a");
    }
    ctx.globalAlpha = 1.0;

    // start/goal
    drawCell(start, "#2f78e3");
    drawCell(goal,  "#dc5a3a");

    // cameFrom arrows (subtle)
    ctx.strokeStyle = "#8d8da6";
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.55;
    for (const [childK,parentK] of ast.cameFrom.entries()){
      const [cx,cy] = parseKey(childK);
      const [px,py] = parseKey(parentK);
      if (!inBounds(cx,cy) || grid[cy][cx]===1) continue;
      const [cpx,cpy] = cellCenter([cx,cy]);
      const [ppx,ppy] = cellCenter([px,py]);
      ctx.beginPath(); ctx.moveTo(cpx,cpy); ctx.lineTo(ppx,ppy); ctx.stroke();
    }
    ctx.globalAlpha = 1.0;

    // g/f text
    ctx.fillStyle = "#d6d6e6";
    ctx.font = "11px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
    for (let y=0;y<GRID_H;y++){
      for (let x=0;x<GRID_W;x++){
        if (grid[y][x]===1) continue;
        const k = key(x,y);
        if (!ast.gScore.has(k)) continue;
        ctx.fillText(`g${fmt(ast.gScore.get(k))}`, x*CELL+4, y*CELL+14);
        ctx.fillText(`f${fmt(ast.fScore.get(k))}`, x*CELL+4, y*CELL+28);
      }
    }

    // optimal path overlay (when complete)
    if (ast.outcome === "reached_goal") {
      const path = reconstructPathStartToGoal(); // keys
      if (path.length) {
        ctx.strokeStyle = "#28d26f";
        ctx.lineWidth = 5;
        ctx.globalAlpha = 0.95;
        ctx.beginPath();
        const [sx,sy] = cellCenter(parseKey(path[0]));
        ctx.moveTo(sx,sy);
        for (let i=1;i<path.length;i++){
          const [x,y] = cellCenter(parseKey(path[i]));
          ctx.lineTo(x,y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;

        // also tint path cells
        ctx.globalAlpha = 0.25;
        for (const pk of path){
          const [x,y] = parseKey(pk);
          if ((x===start[0]&&y===start[1]) || (x===goal[0]&&y===goal[1])) continue;
          drawCell([x,y], "#28d26f");
        }
        ctx.globalAlpha = 1.0;
      }
    }

    drawGridLines();
  }

  function renderVars(){
    const sK = key(start[0],start[1]);
    const gK = key(goal[0],goal[1]);
    const cur = ast.current ?? "-";

    const rows = [
      ["heuristic", heuristicSel.value],
      ["stepCount", String(ast.stepCount)],
      ["start", sK],
      ["goal", gK],
      ["current", cur],
      ["openSet size", String(ast.openSet.size)],
      ["closed size", String(ast.closed.size)],
      ["cameFrom size", String(ast.cameFrom.size)],
      ["gScore(current)", ast.current && ast.gScore.has(ast.current) ? fmt(ast.gScore.get(ast.current)) : "-"],
      ["fScore(current)", ast.current && ast.fScore.has(ast.current) ? fmt(ast.fScore.get(ast.current)) : "-"],
    ];
    varsTbody.innerHTML = rows.map(([k,v]) =>
      `<tr><td>${k}</td><td style="text-align:right">${v}</td></tr>`
    ).join("");

    coreLine.textContent = `priority=f=g+h (tie=insertion order)`;
  }

  function renderOpenTable(){
    const items = [];
    for (const k of ast.openSet){
      const [x,y] = parseKey(k);
      const g = ast.gScore.get(k);
      const h = heuristic([x,y], goal);
      const f = g + h;
      const parent = ast.cameFrom.get(k) ?? "-";
      items.push({k,g,h,f,parent});
    }
    items.sort((a,b) => a.f - b.f || a.h - b.h || a.k.localeCompare(b.k));
    openTbody.innerHTML = items.length
      ? items.slice(0, 24).map(it =>
          `<tr><td>${it.k}</td><td>${fmt(it.g)}</td><td>${fmt(it.h)}</td><td>${fmt(it.f)}</td><td>${it.parent}</td></tr>`
        ).join("")
      : `<tr><td colspan="5" class="muted">empty</td></tr>`;
  }

  function renderNeighborTable(){
    const rows = ast.lastNeighborReport;
    nbrTbody.innerHTML = rows.length
      ? rows.map(r =>
          `<tr><td>${r.nbr}</td><td>${r.pass}</td><td>${r.tentG}</td><td>${r.oldG}</td><td>${r.action}</td></tr>`
        ).join("")
      : `<tr><td colspan="5" class="muted">step to see neighbor checks</td></tr>`;
  }

  function renderPathBox(){
    if (ast.outcome !== "reached_goal") {
      pathBox.textContent = "(not reached yet)";
      return;
    }
    const path = reconstructPathStartToGoal();
    pathBox.textContent = path.length ? path.join("  ->  ") : "(path missing)";
  }

  function renderAll(){
    renderCanvas();
    renderVars();
    renderOpenTable();
    renderNeighborTable();
    renderPathBox();
  }

  // ---------- Interaction ----------
  function mouseToCell(evt){
    const rect = canvas.getBoundingClientRect();
    const mx = evt.clientX - rect.left;
    const my = evt.clientY - rect.top;
    return [Math.floor(mx / CELL), Math.floor(my / CELL)];
  }

  canvas.addEventListener('mousedown', (e) => {
    const [x,y] = mouseToCell(e);
    if (!inBounds(x,y)) return;
    const mode = clickMode.value;

    if (mode === "wall") {
      if ((x===start[0] && y===start[1]) || (x===goal[0] && y===goal[1])) return;
      grid[y][x] = grid[y][x] ? 0 : 1;
      stopRun();
      resetSearch();
    } else if (mode === "start") {
      if (!passable(x,y)) return;
      start = [x,y];
      stopRun();
      resetSearch();
    } else if (mode === "goal") {
      if (!passable(x,y)) return;
      goal = [x,y];
      stopRun();
      resetSearch();
    }
  });

  heuristicSel.addEventListener('change', () => {
    stopRun();
    resetSearch();
  });

  btnStep.onclick = () => stepAStar();
  btnReset.onclick = () => { stopRun(); resetSearch(); };
  btnClear.onclick = () => {
    stopRun();
    for (let y=0;y<GRID_H;y++) for (let x=0;x<GRID_W;x++) grid[y][x]=0;
    resetSearch();
  };

  // ---------- Run/Stop toggle ----------
  let runTimer = null;
  function startRun(){
    if (runTimer) return;
    btnRun.textContent = "Stop";
    const intervalMs = () => Math.max(20, Math.floor(1000 / Number(speed.value)));
    runTimer = setInterval(() => {
      if (ast.finished) { stopRun(); return; }
      stepAStar();
    }, intervalMs());
  }
  function stopRun(){
    if (!runTimer) return;
    clearInterval(runTimer);
    runTimer = null;
    btnRun.textContent = "Run";
  }
  btnRun.onclick = () => runTimer ? stopRun() : startRun();
  speed.addEventListener('input', () => { if (runTimer) { stopRun(); startRun(); } });

  // ---------- Init ----------
  resetSearch();
})();
</script>
</body>
</html>
