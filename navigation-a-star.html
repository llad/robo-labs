<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Robot Nav MVP (A* + Waypoint Follower)</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; background:#0f0f12; color:#ddd; font: 14px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { display:flex; gap:12px; padding:12px; align-items:flex-start; }
    canvas { background:#121218; border:1px solid #2a2a33; }
    .panel { width: 360px; display:flex; flex-direction:column; gap:10px; }
    .card { border:1px solid #2a2a33; background:#121218; padding:10px; border-radius:8px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button, select, input[type="range"] {
      background:#1a1a22; color:#ddd; border:1px solid #2a2a33; border-radius:8px; padding:8px 10px;
    }
    button { cursor:pointer; }
    button:active { transform: translateY(1px); }
    .muted { color:#a9a9b4; }
    .k { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    label { display:flex; gap:8px; align-items:center; }
    .small { font-size: 12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c"></canvas>

    <div class="panel">
      <div class="card">
        <div class="row">
          <button id="btnFollow">Start (Space)</button>
          <button id="btnReplan">Replan (P)</button>
          <button id="btnReset">Reset (R)</button>
          <button id="btnClear">Clear (C)</button>
        </div>
        <div class="row" style="margin-top:8px">
          <label>Draw mode
            <select id="drawMode">
              <option value="wall">Wall</option>
              <option value="erase">Erase</option>
            </select>
          </label>
          <label>Mouse action
            <select id="mouseMode">
              <option value="draw">Draw walls (LMB)</option>
              <option value="setStart">Set start (LMB)</option>
              <option value="setGoal">Set goal (LMB)</option>
            </select>
          </label>
        </div>
        <div class="row" style="margin-top:8px">
          <label class="small">Speed
            <input id="speed" type="range" min="0.2" max="2.0" step="0.1" value="1.0" />
            <span id="speedVal" class="k small">1.0x</span>
          </label>
        </div>
      </div>

      <div class="card">
        <div class="muted small">
          Controls:
          <ul style="margin:6px 0 0 18px; padding:0">
            <li><span class="k">LMB</span>: depends on “Mouse action” (draw/set start/set goal)</li>
            <li><span class="k">RMB</span>: quick set goal</li>
            <li><span class="k">Space</span>: start/stop following</li>
            <li><span class="k">P</span>: replan</li>
            <li><span class="k">R</span>: reset robot to start</li>
            <li><span class="k">C</span>: clear map</li>
          </ul>
        </div>
      </div>

      <div class="card">
        <div id="hud" class="k small"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------------------------
  // Config
  // ---------------------------
  const CELL = 20;
  const GRID_W = 40;
  const GRID_H = 30;
  const W = GRID_W * CELL;
  const H = GRID_H * CELL;

  const canvas = document.getElementById('c');
  canvas.width = W;
  canvas.height = H;
  const ctx = canvas.getContext('2d');

  const btnFollow = document.getElementById('btnFollow');
  const btnReplan = document.getElementById('btnReplan');
  const btnReset  = document.getElementById('btnReset');
  const btnClear  = document.getElementById('btnClear');
  const drawModeSel = document.getElementById('drawMode');
  const mouseModeSel = document.getElementById('mouseMode');
  const speed = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const hud = document.getElementById('hud');

  // ---------------------------
  // Grid: 0 free, 1 wall
  // ---------------------------
  let grid = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0));
  let start = [2, 2];
  let goal = [GRID_W - 3, GRID_H - 3];

  // ---------------------------
  // A*
  // ---------------------------
  const key = (x,y) => `${x},${y}`;
  const parseKey = (k) => k.split(',').map(Number);

  function heuristic(a, b) { return Math.abs(a[0]-b[0]) + Math.abs(a[1]-b[1]); }

  function inBounds(x,y) { return x>=0 && x<GRID_W && y>=0 && y<GRID_H; }
  function passable(x,y) { return grid[y][x] === 0; }

  function neighbors([x,y]) {
    return [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
  }

  function astar(startCell, goalCell) {
    const sK = key(startCell[0], startCell[1]);
    const gK = key(goalCell[0], goalCell[1]);
    if (sK === gK) return { path: [startCell], closed: new Set() };

    // binary heap priority queue
    const heap = [];
    const push = (prio, k) => { heap.push([prio,k]); siftUp(heap.length-1); };
    const pop = () => {
      if (!heap.length) return null;
      const top = heap[0];
      const last = heap.pop();
      if (heap.length) { heap[0]=last; siftDown(0); }
      return top;
    };
    const siftUp = (i) => {
      while (i>0) {
        const p = (i-1)>>1;
        if (heap[p][0] <= heap[i][0]) break;
        [heap[p],heap[i]]=[heap[i],heap[p]];
        i=p;
      }
    };
    const siftDown = (i) => {
      while (true) {
        const l = i*2+1, r=l+1;
        let m=i;
        if (l<heap.length && heap[l][0] < heap[m][0]) m=l;
        if (r<heap.length && heap[r][0] < heap[m][0]) m=r;
        if (m===i) break;
        [heap[m],heap[i]]=[heap[i],heap[m]];
        i=m;
      }
    };

    const cameFrom = new Map();
    const gScore = new Map([[sK, 0]]);
    const fScore = new Map([[sK, heuristic(startCell, goalCell)]]);
    const closed = new Set();

    push(fScore.get(sK), sK);

    while (heap.length) {
      const [, curK] = pop();
      if (closed.has(curK)) continue;
      closed.add(curK);

      if (curK === gK) {
        const path = [];
        let kNow = curK;
        while (kNow) {
          const [x,y] = parseKey(kNow);
          path.push([x,y]);
          kNow = cameFrom.get(kNow);
        }
        path.reverse();
        return { path, closed };
      }

      const [cx, cy] = parseKey(curK);
      for (const [nx,ny] of neighbors([cx,cy])) {
        if (!inBounds(nx,ny) || !passable(nx,ny)) continue;
        const nk = key(nx,ny);

        const tentative = gScore.get(curK) + 1;
        if (!gScore.has(nk) || tentative < gScore.get(nk)) {
          cameFrom.set(nk, curK);
          gScore.set(nk, tentative);
          const f = tentative + heuristic([nx,ny], goalCell);
          fScore.set(nk, f);
          push(f, nk);
        }
      }
    }
    return { path: [], closed };
  }

  // ---------------------------
  // Robot (continuous pose in pixels)
  // ---------------------------
  function cellCenter([cx,cy]) { return [(cx+0.5)*CELL, (cy+0.5)*CELL]; }

  const robot = {
    x: cellCenter(start)[0],
    y: cellCenter(start)[1],
    theta: 0,
    v: 0,
    w: 0,
    reset() {
      [this.x,this.y] = cellCenter(start);
      this.theta = 0;
      this.v = 0;
      this.w = 0;
    },
    cell() { return [Math.floor(this.x / CELL), Math.floor(this.y / CELL)]; },
    update(dt) {
      this.theta += this.w * dt;
      this.x += Math.cos(this.theta) * this.v * dt;
      this.y += Math.sin(this.theta) * this.v * dt;
      // clamp to world
      this.x = Math.max(1, Math.min(W-2, this.x));
      this.y = Math.max(1, Math.min(H-2, this.y));
    }
  };

  // ---------------------------
  // Planning / Following state
  // ---------------------------
  let follow = false;
  let path = [];
  let closed = new Set();
  let waypointI = 0;

  function replan() {
    const res = astar(start, goal);
    path = res.path;
    closed = res.closed;
    waypointI = 0;
    if (follow && !path.length) follow = false;
  }

  replan();

  // ---------------------------
  // Input helpers
  // ---------------------------
  function mouseToCell(evt) {
    const rect = canvas.getBoundingClientRect();
    const mx = evt.clientX - rect.left;
    const my = evt.clientY - rect.top;
    return [Math.floor(mx / CELL), Math.floor(my / CELL)];
  }

  function setStart(cell) {
    const [x,y] = cell;
    if (!inBounds(x,y) || !passable(x,y)) return;
    start = [x,y];
    robot.reset();
    replan();
  }

  function setGoal(cell) {
    const [x,y] = cell;
    if (!inBounds(x,y) || !passable(x,y)) return;
    goal = [x,y];
    replan();
  }

  function applyDraw(cell) {
    const [x,y] = cell;
    if (!inBounds(x,y)) return;
    if ((x===start[0] && y===start[1]) || (x===goal[0] && y===goal[1])) return;

    const mode = drawModeSel.value;
    grid[y][x] = (mode === "wall") ? 1 : 0;
    replan();
  }

  let dragging = false;

  canvas.addEventListener('contextmenu', e => e.preventDefault());
  canvas.addEventListener('mousedown', (e) => {
    const cell = mouseToCell(e);
    if (e.button === 2) { // right
      setGoal(cell);
      return;
    }
    if (e.button !== 0) return;

    dragging = true;
    const mm = mouseModeSel.value;
    if (mm === "draw") applyDraw(cell);
    else if (mm === "setStart") setStart(cell);
    else if (mm === "setGoal") setGoal(cell);
  });

  window.addEventListener('mouseup', () => dragging = false);

  canvas.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    if (mouseModeSel.value !== "draw") return;
    applyDraw(mouseToCell(e));
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === ' ') { e.preventDefault(); toggleFollow(); }
    if (e.key.toLowerCase() === 'p') replan();
    if (e.key.toLowerCase() === 'r') { robot.reset(); waypointI = 0; }
    if (e.key.toLowerCase() === 'c') { grid = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0)); replan(); }
  });

  // ---------------------------
  // UI actions
  // ---------------------------
  function toggleFollow() {
    follow = !follow;
    if (follow && !path.length) follow = false;
    btnFollow.textContent = follow ? "Stop (Space)" : "Start (Space)";
  }

  btnFollow.onclick = toggleFollow;
  btnReplan.onclick = replan;
  btnReset.onclick = () => { robot.reset(); waypointI = 0; };
  btnClear.onclick = () => { grid = Array.from({length: GRID_H}, () => Array(GRID_W).fill(0)); replan(); };

  speed.addEventListener('input', () => speedVal.textContent = `${Number(speed.value).toFixed(1)}x`);

  // ---------------------------
  // Simulation loop
  // ---------------------------
  let lastT = performance.now();

  function step(t) {
    const dtRaw = (t - lastT) / 1000;
    lastT = t;

    // cap dt to avoid huge jumps (tab switching)
    const dt = Math.min(0.05, dtRaw) * Number(speed.value);

    if (follow && path.length) {
      if (waypointI >= path.length) {
        robot.v = 0; robot.w = 0; follow = false;
        btnFollow.textContent = "Start (Space)";
      } else {
        const targetCell = path[waypointI];
        const [tx, ty] = cellCenter(targetCell);
        const dx = tx - robot.x, dy = ty - robot.y;
        const dist = Math.hypot(dx, dy);

        if (dist < 6) {
          waypointI++;
        } else {
          const desired = Math.atan2(dy, dx);
          let err = desired - robot.theta;
          err = ((err + Math.PI) % (2*Math.PI)) - Math.PI;

          // proportional heading controller
          robot.w = 6.0 * err;
          robot.v = 120.0 * Math.max(0, 1 - Math.abs(err));

          // stop if next step hits a wall
          const nx = Math.floor((robot.x + Math.cos(robot.theta) * 8) / CELL);
          const ny = Math.floor((robot.y + Math.sin(robot.theta) * 8) / CELL);
          if (inBounds(nx,ny) && grid[ny][nx] === 1) robot.v = 0;

          robot.update(dt);
        }
      }
    }

    draw();
    requestAnimationFrame(step);
  }

  // ---------------------------
  // Rendering
  // ---------------------------
  function drawCell([x,y], fill) {
    ctx.fillStyle = fill;
    ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
  }

  function drawGrid() {
    ctx.strokeStyle = "#2a2a33";
    ctx.lineWidth = 1;
    for (let x=0; x<=W; x+=CELL) {
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for (let y=0; y<=H; y+=CELL) {
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
  }

  function drawRobot() {
    // body
    ctx.fillStyle = "#dcdcff";
    ctx.beginPath();
    ctx.arc(robot.x, robot.y, CELL/3, 0, Math.PI*2);
    ctx.fill();

    // heading
    const hx = robot.x + Math.cos(robot.theta) * (CELL/2);
    const hy = robot.y + Math.sin(robot.theta) * (CELL/2);
    ctx.strokeStyle = "#ffc862";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(robot.x, robot.y);
    ctx.lineTo(hx, hy);
    ctx.stroke();
  }

  function draw() {
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#0f0f12";
    ctx.fillRect(0,0,W,H);

    // walls
    for (let y=0; y<GRID_H; y++) {
      for (let x=0; x<GRID_W; x++) {
        if (grid[y][x] === 1) drawCell([x,y], "#4a4a4a");
      }
    }

    // closed/explored (don’t overpaint walls)
    ctx.globalAlpha = 0.85;
    for (const ck of closed) {
      const [x,y] = parseKey(ck);
      if (grid[y][x] === 1) continue;
      if (x===start[0] && y===start[1]) continue;
      if (x===goal[0] && y===goal[1]) continue;
      drawCell([x,y], "#1b2a40");
    }
    ctx.globalAlpha = 1.0;

    // path
    for (const [x,y] of path) {
      if (x===start[0] && y===start[1]) continue;
      if (x===goal[0] && y===goal[1]) continue;
      drawCell([x,y], "#23512d");
    }

    // start/goal
    drawCell(start, "#2f78e3");
    drawCell(goal,  "#dc5a3a");

    drawGrid();
    drawRobot();

    // HUD
    hud.innerText =
      `path_len=${path.length}  waypoint=${Math.min(waypointI, Math.max(0,path.length-1))}/${Math.max(0,path.length-1)}\n` +
      `robot_cell=${robot.cell().join(',')}  follow=${follow}\n` +
      `start=${start.join(',')}  goal=${goal.join(',')}`;
  }

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
